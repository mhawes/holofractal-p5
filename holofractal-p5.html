<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>p5.js App</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body>
    <script>
        function setup() {
            createCanvas(windowWidth, windowHeight);
            background(220);
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            background(220);
        }

        
        // Set this variable externally to control the circle size (e.g., from an audio visualizer)
        window.externalCircleDiameter = window.externalCircleDiameter || null;

        function draw() {
            background(2, 2, 2, 10); // subtle dark background

            // Circle "wave" system: circles keep expanding, new ones spawn at center when maxD is reached
            if (typeof window.circles === 'undefined') {
            window.circles = [];
            }

            let minD = 1;
            let maxD = width;
            let speed = 2;

            // If external control, just draw one circle at that size everywhere
            if (window.externalCircleDiameter !== null) {
            window.circles = [{ d: Math.max(minD, Math.min(maxD, window.externalCircleDiameter)) }];
            } else {
            // Spawn a new circle if none exist or last one reached maxD
            if (
                window.circles.length === 0 ||
                window.circles[window.circles.length - 1].d >= maxD
            ) {
                window.circles.push({ d: minD });
            }
            // Grow all circles
            for (let c of window.circles) {
                c.d += speed;
            }
            // Remove circles that are way too big (for memory)
            window.circles = window.circles.filter(c => c.d <= maxD * 2);
            }

            let r = 200; // distance between circle centers
            let cols = Math.ceil(width / (r * 1.5)) + 2;
            let rows = Math.ceil(height / (r * Math.sqrt(3))) + 2;

            // Center of canvas
            let cx = width / 2;
            let cy = height / 2;

            colorMode(HSB, 360, 100, 100, 255);
            noFill();
            strokeWeight(2);

            // Always draw the grid so that one grid point is exactly at the center
            // Calculate the offset so that (cx, cy) is a grid point
            // For hex grid, the center column and row:
            let centerCol = Math.floor(cols / 2);
            let centerRow = Math.floor(rows / 2);

            for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Hexagonal grid offset
                let x = cx + (col - centerCol) * r * 1.5;
                let y = cy + (row - centerRow) * r * Math.sqrt(3) + ((col % 2) * (r * Math.sqrt(3) / 2));

                // Distance from center
                let distToCenter = dist(x, y, cx, cy);

                // Max distance is from center to farthest corner
                let maxDist = dist(0, 0, Math.max(cx, width - cx), Math.max(cy, height - cy));
                let hue = map(distToCenter, 0, maxDist, 0, 360);

                // Center circle is fully opaque, others are semi-transparent
                if (Math.abs(x - cx) < 1 && Math.abs(y - cy) < 1) {
                stroke(hue, 80, 100, 255);
                } else {
                stroke(hue, 80, 100, 180);
                }

                // Draw all expanding circles at this grid point
                for (let c of window.circles) {
                ellipse(x, y, c.d, c.d);
                }
            }
            }

            colorMode(RGB, 255, 255, 255, 255); // reset color mode
        }
    </script>
</body>
</html>